---
title: "Data visualization with ggplot2 - Answers"
output: html_notebook
editor_options: 
  markdown: 
    wrap: 72
---


This lesson is adapted from the [Data Analysis and Visualization in R for Ecologists 2.](https://datacarpentry.github.io/R-ecology-lesson/visualizing-ggplot.html)

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you
execute code within the notebook, the results appear beneath the code.

Execute code chunks by clicking the *Run* button within the chunk or by
placing your cursor inside it and pressing *Cmd+Shift+Enter* or
*Ctrl+Shift+Enter*.

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or
by pressing *Cmd+Option+I*.

When you save the notebook, a HTML file containing the code and output
will be saved alongside it (click the *Preview* button or press
*Cmd+Shift+K* or *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the
editor. Consequently, unlike *Knit*, *Preview* does not run any R code
chunks. Instead, the output of the chunk when it was last run in the
editor is displayed.

## 1. Setup

We start by loading the required packages. **`ggplot2`** is included in
the **`tidyverse`** package.

```{r}
library(tidyverse)
```

Later we will learn how to read data from external files into R, but for now we are going to use a clean and ready-to-use dataset that is provided by the ratdat data package. To make our dataset available, we need to load this package too.

```{r}
library(ratdat)
```

The ratdat package contains data from the [Portal Project](https://github.com/weecology/PortalData), which is a long-term dataset from Portal, Arizona, in the Chihuahuan desert.

We will be using a dataset called complete_old, which contains older years of survey data. Let’s try to learn a little bit about the data. We can use a ? in front of the name of the dataset, which will bring up the help page for the data.


```{r}
?complete_old
```

Here we can read descriptions of each variable in our data.

To actually take a look at the data, we can use the View() function to open an interactive viewer, which behaves like a simplified version of a spreadsheet program. It’s a handy function, but somewhat limited when trying to view large datasets.

```{r}
View(complete_old)
```

If you hover over the tab for the interactive View(), you can click the “x” that appears, which will close the tab.

We can find out more about the dataset by using the str() function to examine the structure of the data.

```{r}
str(complete_old)
```

str() will tell us how many observations/rows (obs) and variables/columns we have, as well as some information about each of the variables. We see the name of a variable (such as year), followed by the kind of variable (int for integer, chr for character), and the first 10 entries in that variable. We will talk more about different data types and structures later on.


## 1. Plotting with **`ggplot2`**


**`ggplot2`** is a powerful package that allows you to create complex plots from tabular data (data in a table format with rows and columns). The gg in ggplot2 stands for “grammar of graphics”, and the package uses consistent vocabulary to create plots of widely varying types. Therefore, we only need small changes to our code if the underlying data changes or we decide to make a box plot instead of a scatter plot. This approach helps you create publication-quality plots with minimal adjusting and tweaking.

**`ggplot2`** is part of the **`tidyverse`** series of packages, which tend to like data in the “long” or “tidy” format, which means each column represents a single variable, and each row represents a single observation. Well-structured data will save you lots of time making figures with **`ggplot2`**. For now, we will use data that are already in this format. We start learning R by using **`ggplot2`** because it relies on concepts that we will need when we talk about data transformation in the next lessons.

**`ggplot`** plots are built step by step by adding new layers, which allows for extensive flexibility and customization of plots.


Some languages, like Python, require certain spacing or indentation for code to run properly. This isn’t the case in R, so if you see spaces or indentation in the code from this lesson, it is to improve readability.

### 1.1 Basic template for ggplot

To build a plot, we will use a basic template that can be used for different types of plots:

```         
ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +  <GEOM_FUNCTION>()
```

### 1.2 Bind a data frame

-   We use the `ggplot()` function to create a plot. In order to tell it what data to use, we need to specify the `data` argument. An argument is an input that a function takes, and you set arguments using the = sign.

```{r first_ggplot}
# ggplot with data
ggplot(data = complete_old)
```


Note: You'll see we have started naming some of our our 'code chunks',
like 'first-ggplot'. The name is optional but if included, each code
chunk needs a distinct name. The advantage of giving each chunk a name
is that it will be easier to understand where to look for errors, should
they occur. Also, any figures that are created will be given names based
on the name of the code chunk that produced them.

### 1.3 Define an `aes`mapping

We get a blank plot because we haven’t told `ggplot()` which variables we want to correspond to parts of the plot. We can specify the “mapping” of variables to plot elements, such as x/y coordinates, size, or shape, by using the `aes()` function. We’ll also add a comment, which is any line starting with a `#`. It’s a good idea to use comments to organize your code or clarify what you are doing.


```{r first ggplot}
# adding a mapping to x and y axes
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length))
```


### 1.4 Add 'geoms'

Now we’ve got a plot with x and y axes corresponding to variables from `complete_old`. However, we haven’t specified how we want the data to be displayed. We do this using `geom_` functions, which specify the type of geometry we want, such as points, lines, or bars. We can add a `geom_point()` layer to our plot by using the + sign. We indent onto a new line to make it easier to read, and we have to end the first line with the `+` sign.


-   add 'geoms' – graphical representations of the data in the plot
    (points, lines, bars). **`ggplot2`** offers many different geoms; we
    will use some common ones today, including:

    -   `geom_point()` for scatter plots, dot plots, etc.
    -   `geom_boxplot()` for, well, boxplots!
    -   `geom_line()` for trend lines, time series, etc.

Because we have two continuous variables, let's use `geom_point()` first:

```{r first_ggplot_geom_point}
# adding a geom_point
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length)) +
  geom_point()

```

You may notice a warning that missing values were removed. If a variable necessary to make the plot is missing from a given row of data (in this case,`hindfoot_length` or `weight`), it can’t be plotted. **`ggplot2`** just uses a warning message to let us know that some rows couldn’t be plotted.


### Callout
**Warning** messages are one of a few ways R will communicate with you. Warnings can be thought of as a “heads up”. Nothing necessarily went wrong, but the author of that function wanted to draw your attention to something. In the above case, it’s worth knowing that some of the rows of your data were not plotted because they had missing data.

A more serious type of message is an error. Here’s an example:


```{r}
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length)) +
  geom_poit()
```

As you can see, we only get the error message, with no plot, because something has actually gone wrong. This particular error message is fairly common, and it happened because we misspelled point as poit. Because there is no function named geom_poit(), R tells us it can’t find a function with that name.

### 1.5 Changing aesthetics

Building `ggplot` plots is often an iterative process, so we’ll continue developing the scatter plot we just made. You may have noticed that parts of our scatter plot have many overlapping points, making it difficult to see all the data. We can adjust the transparency of the points using the `alpha` argument, which takes a value between 0 and 1:

```{r first_ggplot_alpha}
# adding transparency
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length)) +
  geom_point(alpha = 0.2)
```


We can also change the colour of the points:

```{r first_ggplot_alpha_colour}
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length)) +
  geom_point(alpha = 0.2, colour = "blue")
```
### Callout
Two common issues you might run into when working in R are forgetting a closing bracket or a closing quote. Let’s take a look at what each one does.

Try running the following code:


```{r}
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length)) +
  geom_point(colour = "blue", alpha = 0.2
```


You will see a `+` appear in your console. This is R telling you that it expects more input in order to finish running the code. It is missing a closing bracket to end the geom_point function call. You can hit `Esc` in the console to reset it.

You will also see a red cross in the code cell. If you hover over it, a helpful message will appear.

Something similar will happen if you run the following code:

```{r}
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length)) +
  geom_point(colour = "blue, alpha = 0.2)
```

A missing quote at the end of blue means that the rest of the code is treated as part of the quote, which is a bit easier to see since RStudio displays character strings in a different colour.

You will get a different error message if you run the following code:

```{r}
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length)) +
  geom_point(colour = "blue", alpha = 0.2))
```

This time we have an extra closing ), which R doesn’t know what to do with. It tells you there is an unexpected ), but it doesn’t pinpoint exactly where (though the hover message on the red cross in the code cell does a better job!). With enough time working in R, you will get better at spotting mismatched brackets.

### 1.6 Adding another variable

Let’s try colouring our points according to the sampling plot type (plot here refers to the physical area where rodents were sampled and has nothing to do with making graphs). Since we’re now mapping a variable (`plot_type`) to a component of the ggplot2 plot (`colour`), we need to put the argument inside `aes()`:


```{r first_ggplot_add_variable}
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length, colour = plot_type)) +
  geom_point(alpha = 0.2)
```


### Challenge 1.a: Modifying plots
Try modifying the plot so that the shape of the point varies by sex. You will set the shape the same way you set the color.
Do you think this is a good way to represent sex with these data?

```{r challenge1a}
ggplot(data = complete_old, 
       mapping = aes(x = weight, y = hindfoot_length, shape = sex)) +
  geom_point(alpha = 0.2)
```


### Challenge 1.b: Modifying plots
Now try changing the plot so that the color of the points vary by year. Do you notice a difference in the color scale compared to changing color by plot type? Why do you think this happened?


```{r challenge1b}
ggplot(data = complete_old, 
       mapping = aes(x = weight, y = hindfoot_length, color = year)) +
  geom_point(alpha = 0.2)
```

For Part 2, the color scale is different compared to using color = plot_type because plot_type and year are different variable types. plot_type is a categorical variable, so **`ggplot2`** defaults to use a **discrete** color scale, whereas year is a numeric variable, so ggplot2 uses a **continuous** color scale.


### 1.7 Changing scales
The default discrete color scale isn’t always ideal: it isn’t friendly to viewers with colorblindness and it doesn’t translate well to grayscale. However, **`ggplot2`** comes with quite a few other color scales, including the fantastic `viridis` scales, which are designed to be colorblind and grayscale friendly. We can change scales by adding `scale_` functions to our plots:


```{r first_ggplot_change_scale}
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length, color = plot_type)) +
  geom_point(alpha = 0.2) +
  scale_color_viridis_d()
```

Scales don’t just apply to colors- any plot component that you put inside `aes()` can be modified with `scale_` functions. Just as we modified the scale used to map `plot_type` to `colour`, we can modify the way that `weight` is mapped to the x axis by using the `scale_x_log10()` function:

```{r first_ggplot_change_scalelog}
ggplot(data = complete_old, mapping = aes(x = weight, y = hindfoot_length, colour = plot_type)) +
  geom_point(alpha = 0.2) +
  scale_x_log10()
```


One nice thing about ggplot and the tidyverse in general is that groups of functions that do similar things are given similar names. Any function that modifies a ggplot scale starts with `scale_`, making it easier to search for the right function.

### 1.8 Boxplot

Let’s try making a different type of plot altogether. We’ll start off with our same basic building blocks using ggplot() and aes().

```{r}
ggplot(data = complete_old, mapping = aes(x = plot_type, y = hindfoot_length))

```


